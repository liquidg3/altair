{
  "name": "underscore-query",
  "description": "Lightweight Query API mixin for Underscore or Lodash (MODIFIED TO NOT DIVE INTO CONSTRUCTED OBJECTS)",
  "version": "0.4.0",
  "author": {
    "name": "Dave Tonge",
    "email": "dave@simplecreativity.co.uk",
    "url": "https://github.com/davidgtonge"
  },
  "tags": [
    "underscore",
    "mongo",
    "lodash",
    "query"
  ],
  "main": "./lib/underscore-query",
  "repository": {
    "type": "git",
    "url": "git@github.com:liquidg3/underscore-query.git"
  },
  "dependencies": {
    "underscore": ">=1.1.x"
  },
  "gitHead": "d3f14a6e4c10590341639bc85ce1874eefc10921",
  "readme": "underscore-query\n===================\n\n[![Build Status](https://secure.travis-ci.org/davidgtonge/underscore-query.png)](http://travis-ci.org/davidgtonge/underscore-query)\n\nA lightweight query API plugin for Underscore.js - works in the Browser and on the Server.\nThis project was originally [Backbone Query](https://github.com/davidgtonge/backbone_query), however I found that it\nwas useful to have the ability to query arrays as well as Backbone Collections. So the library has been ported to\nunderscore, and backbone-query now uses underscore-query.\n\nIn updating the prokect serveral new features have been added, including the ability to use a chainable query api.\n\n### Features\n\n - Search for objects with a Query API similar to [MongoDB](http://www.mongodb.org/display/DOCS/Advanced+Queries)\n - Use a complex query object, or build queries up with a chainable api\n - Full support for compound queries ($not, $nor, $or, $and), including nested compound queries.\n - Full support for querying nested arrays (see `$elemMatch`)\n - Accepts dot notation to query deep properties (e.g. {\"stats.views.december\": 100}\n - Custom getters can be defined, (e.g. `.get` for Backbone)\n - Works well with underscore chaining\n\nPlease report any bugs, feature requests in the issue tracker.\nPull requests are welcome!\n\n\nInstallation\n============\n\n#### Client Side Installation:\nTo install, include the `lib/underscore-query.min.js` file in your HTML page, after Underscore (or Lodash).\n`_.query` will now be available for you to use.\n\nIf you use AMD, then you can use \"lib/underscore-query.amd.js\".\nThis will return a function that accepts either underscore or lodash. This function\nalso accepts an optional boolean argument on whether to mixin the query methods to underscore/lodash.\nIf you are using AMD and you want the methods mixed in, then you'd only need to require \"underscore-query\" once\nprobably in your init script:\n\n```js\ndefine('myModule',\n    ['underscore', 'underscore-query'],\n    function ( _, underscoreQuery ) {\n        // opt 1\n        underscoreQuery(_); // _.query is now available on the underscore module\n        // opt 2\n        var query = underscoreQuery(_, false) // query is available as a local variable with all the query methods\n    }\n```\n\n#### Server side (node.js) installation\nYou can install with NPM: `npm install underscore-query`\nThe library can work with either lodash or underscore, when you first require it in it exposes a method that takes\neither underscore or lodash:\n\n```ja\n// With Underscore\n_ = require(\"underscore\");\nrequire(\"underscore-query\")(_);\n\n// With Lodash\n_ = require(\"lodash\");\nrequire(\"underscore-query(_);\n\n// If you don't want the query methods 'mixed in'\n_ = require(\"underscore\");\nquery = require(\"underscore-query\")(_, false);\n```\n\n\n\nBasic Usage\n===========\n\nThe following are some basic examples:\n\n```js\n_.query( MyCollection, {\n    featured:true, \n    likes: {$gt:10}\n});\n// Returns all models where the featured attribute is true and there are\n// more than 10 likes\n\n_.query( MyCollection, {tags: { $any: [\"coffeescript\", \"backbone\", \"mvc\"]}});\n// Finds models that have either \"coffeescript\", \"backbone\", \"mvc\" in their \"tags\" attribute\n\n_.query(MyCollection, {\n  // Models must match all these queries\n  $and:{\n    title: {$like: \"news\"}, // Title attribute contains the string \"news\"\n    likes: {$gt: 10}\n  }, // Likes attribute is greater than 10\n\n  // Models must match one of these queries\n  $or:{\n    featured: true, // Featured attribute is true\n    category:{$in:[\"code\",\"programming\",\"javascript\"]}\n  } \n  //Category attribute is either \"code\", \"programming\", or \"javascript\"\n});\n\ntitles = _.query.build( MyCollection )\n  .and(\"published\", true)\n  .or(\"likes\", {$gt:10})\n  .or(\"tags\":[\"javascript\", \"coffeescript\"])\n  .chain()\n  .sortBy(_.query.get(\"likes\"))\n  .pluck(\"title\")\n  .value();\n// Builds a query up programatically\n// Runs the query, sort's by likes, and plucks the titles.\n\n\nquery = _.query.build()\n  .and(\"published\", true)\n  .or(\"likes\", {$gt:10})\n  .or(\"tags\":[\"javascript\", \"coffeescript\"])\n\nresultsA = query.all(collectionA)\nresultsB = query.all(collectionB)\n// Builds a query and then runs it on 2 seperate collections\n\n```\n\nOr if CoffeeScript is your thing (the source is written in CoffeeScript), try this:\n\n```coffeescript\n_.query MyCollection,\n  $and:\n    likes: $lt: 15\n  $or:\n    content: $like: \"news\"\n    featured: $exists: true\n  $not:\n    colors: $contains: \"yellow\"\n```\n\n\n\nQuery API\n===\n\n### $equal\nPerforms a strict equality test using `===`. If no operator is provided and the query value isn't a regex then `$equal` is assumed.\n\nIf the attribute in the model is an array then the query value is searched for in the array in the same way as `$contains`\n\nIf the query value is an object (including array) then a deep comparison is performed using underscores `_.isEqual`\n\n```javascript\n_.query( MyCollection, { title:\"Test\" });\n// Returns all models which have a \"title\" attribute of \"Test\"\n\n_.query( MyCollection, { title: {$equal:\"Test\"} }); // Same as above\n\n_.query( MyCollection, { colors: \"red\" });\n// Returns models which contain the value \"red\" in a \"colors\" attribute that is an array.\n\nMyCollection.query ({ colors: [\"red\", \"yellow\"] });\n// Returns models which contain a colors attribute with the array [\"red\", \"yellow\"]\n```\n\n### $contains\nAssumes that the model property is an array and searches for the query value in the array\n\n```js\n_.query( MyCollection, { colors: {$contains: \"red\"} });\n// Returns models which contain the value \"red\" in a \"colors\" attribute that is an array.\n// e.g. a model with this attribute colors:[\"red\",\"yellow\",\"blue\"] would be returned\n```\n\n### $ne\n\"Not equal\", the opposite of $equal, returns all models which don't have the query value\n\n```js\n_.query( MyCollection, { title: {$ne:\"Test\"} });\n// Returns all models which don't have a \"title\" attribute of \"Test\"\n```\n\n### $lt, $lte, $gt, $gte\nThese conditional operators can be used for greater than and less than comparisons in queries\n\n```js\n_.query( MyCollection, { likes: {$lt:10} });\n// Returns all models which have a \"likes\" attribute of less than 10\n_.query( MyCollection, { likes: {$lte:10} });\n// Returns all models which have a \"likes\" attribute of less than or equal to 10\n_.query( MyCollection, { likes: {$gt:10} });\n// Returns all models which have a \"likes\" attribute of greater than 10\n_.query( MyCollection, { likes: {$gte:10} });\n// Returns all models which have a \"likes\" attribute of greater than or equal to 10\n```\n\n### $between\nTo check if a value is in-between 2 query values use the $between operator and supply an array with the min and max value\n\n```js\n_.query( MyCollection, { likes: {$between:[5,15] } });\n// Returns all models which have a \"likes\" attribute of greater than 5 and less then 15\n```\n\n### $in\nAn array of possible values can be supplied using $in, a model will be returned if any of the supplied values is matched\n\n```js\n_.query( MyCollection, { title: {$in:[\"About\", \"Home\", \"Contact\"] } });\n// Returns all models which have a title attribute of either \"About\", \"Home\", or \"Contact\"\n```\n\n### $nin\n\"Not in\", the opposite of $in. A model will be returned if none of the supplied values is matched\n\n```js\n_.query( MyCollection, { title: {$nin:[\"About\", \"Home\", \"Contact\"] } });\n// Returns all models which don't have a title attribute of either\n// \"About\", \"Home\", or \"Contact\"\n```\n\n### $all\nAssumes the model property is an array and only returns models where all supplied values are matched.\n\n```js\n_.query( MyCollection, { colors: {$all:[\"red\", \"yellow\"] } });\n// Returns all models which have \"red\" and \"yellow\" in their colors attribute.\n// A model with the attribute colors:[\"red\",\"yellow\",\"blue\"] would be returned\n// But a model with the attribute colors:[\"red\",\"blue\"] would not be returned\n```\n\n### $any\nAssumes the model property is an array and returns models where any of the supplied values are matched.\n\n```js\n_.query( MyCollection, { colors: {$any:[\"red\", \"yellow\"] } });\n// Returns models which have either \"red\" or \"yellow\" in their colors attribute.\n```\n\n### $size\nAssumes the model property has a length (i.e. is either an array or a string).\nOnly returns models the model property's length matches the supplied values\n\n```js\n_.query( MyCollection, { colors: {$size:2 } });\n// Returns all models which 2 values in the colors attribute\n```\n\n### $exists or $has\nChecks for the existence of an attribute. Can be supplied either true or false.\n\n```js\n_.query( MyCollection, { title: {$exists: true } });\n// Returns all models which have a \"title\" attribute\n_.query( MyCollection, { title: {$has: false } });\n// Returns all models which don't have a \"title\" attribute\n```\n\n### $like\nAssumes the model attribute is a string and checks if the supplied query value is a substring of the property.\nUses indexOf rather than regex for performance reasons\n\n```js\n_.query( MyCollection, { title: {$like: \"Test\" } });\n//Returns all models which have a \"title\" attribute that\n//contains the string \"Test\", e.g. \"Testing\", \"Tests\", \"Test\", etc.\n```\n\n### $likeI\nThe same as above but performs a case insensitive search using indexOf and toLowerCase (still faster than Regex)\n\n```js\n_.query( MyCollection, { title: {$likeI: \"Test\" } });\n//Returns all models which have a \"title\" attribute that\n//contains the string \"Test\", \"test\", \"tEst\",\"tesT\", etc.\n```\n\n### $regex\nChecks if the model attribute matches the supplied regular expression. The regex query can be supplied without the `$regex` keyword\n\n```js\n_.query( MyCollection, { content: {$regex: /coffeescript/gi } });\n// Checks for a regex match in the content attribute\n_.query( MyCollection, { content: /coffeescript/gi });\n// Same as above\n```\n\n### $cb\nA callback function can be supplied as a test. The callback will receive the attribute and should return either true or false.\n`this` will be set to the current model, this can help with tests against computed properties\n\n```js\n_.query( MyCollection, { title: {$cb: function(attr){ return attr.charAt(0) === \"c\";}} });\n// Returns all models that have a title attribute that starts with \"c\"\n\n_.query( MyCollection, { computed_test: {$cb: function(){ return this.computed_property() > 10;}} });\n// Returns all models where the computed_property method returns a value greater than 10.\n```\n\nFor callbacks that use `this` rather than the model attribute, the key name supplied is arbitrary and has no\neffect on the results. If the only test you were performing was like the above test it would make more sense\nto simply use `MyCollection.filter`. However if you are performing other tests or are using the paging / sorting /\ncaching options of backbone query, then this functionality is useful.\n\n### $elemMatch\nThis operator allows you to perform queries in nested arrays similar to [MongoDB](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24elemMatch)\nFor example you may have a collection of models in with this kind of data stucture:\n\n```js\nvar Posts = new QueryCollection([\n    {title: \"Home\", comments:[\n      {text:\"I like this post\"},\n      {text:\"I love this post\"},\n      {text:\"I hate this post\"}\n    ]},\n    {title: \"About\", comments:[\n      {text:\"I like this page\"},\n      {text:\"I love this page\"},\n      {text:\"I really like this page\"}\n    ]}\n]);\n```\nTo search for posts which have the text \"really\" in any of the comments you could search like this:\n\n```js\nPosts.query({\n  comments: {\n    $elemMatch: {\n      text: /really/i\n    }\n  }\n});\n```\n\nAll of the operators above can be performed on `$elemMatch` queries, e.g. `$all`, `$size` or `$lt`.\n`$elemMatch` queries also accept compound operators, for example this query searches for all posts that\nhave at least one comment without the word \"really\" and with the word \"totally\".\n```js\nPosts.query({\n  comments: {\n    $elemMatch: {\n      $not: {\n        text: /really/i\n      },\n      $and: {\n        text: /totally/i\n      }\n    }\n  }\n});\n```\n\n\n### $computed\nThis operator allows you to perform queries on computed properties. For example you may want to perform a query\nfor a persons full name, even though the first and last name are stored separately in your db / model.\nFor example\n\n```js\ntestModel = Backbone.Model.extend({\n  full_name: function() {\n    return (this.get('first_name')) + \" \" + (this.get('last_name'));\n  }\n});\n\na = new testModel({\n  first_name: \"Dave\",\n  last_name: \"Tonge\"\n});\n\nb = new testModel({\n  first_name: \"John\",\n  last_name: \"Smith\"\n});\n\nMyCollection = new QueryCollection([a, b]);\n\n_.query( MyCollection, {\n  full_name: { $computed: \"Dave Tonge\" }\n});\n// Returns the model with the computed `full_name` equal to Dave Tonge\n\n_.query( MyCollection, {\n  full_name: { $computed: { $likeI: \"john smi\" } }\n});\n// Any of the previous operators can be used (including elemMatch is required)\n```\n\n\nCombined Queries\n================\n\nMultiple queries can be combined together. By default all supplied queries use the `$and` operator. However it is possible\nto specify either `$or`, `$nor`, `$not` to implement alternate logic.\n\n### $and\n\n```js\n_.query( MyCollection, { $and: { title: {$like: \"News\"}, likes: {$gt: 10}}});\n// Returns all models that contain \"News\" in the title and have more than 10 likes.\n_.query( MyCollection, { title: {$like: \"News\"}, likes: {$gt: 10} });\n// Same as above as $and is assumed if not supplied\n```\n\n### $or\n\n```js\n_.query( MyCollection, { $or: { title: {$like: \"News\"}, likes: {$gt: 10}}});\n// Returns all models that contain \"News\" in the title OR have more than 10 likes.\n```\n\n### $nor\nThe opposite of `$or`\n\n```js\n_.query( MyCollection, { $nor: { title: {$like: \"News\"}, likes: {$gt: 10}}});\n// Returns all models that don't contain \"News\" in the title NOR have more than 10 likes.\n```\n\n### $not\nThe opposite of `$and`\n\n```js\n_.query( MyCollection, { $not: { title: {$like: \"News\"}, likes: {$gt: 10}}});\n// Returns all models that don't contain \"News\" in the title AND DON'T have more than 10 likes.\n```\n\nIf you need to perform multiple queries on the same key, then you can supply the query as an array:\n```js\n_.query( MyCollection, {\n    $or:[\n        {title:\"News\"},\n        {title:\"About\"}\n    ]\n});\n// Returns all models with the title \"News\" or \"About\".\n```\n\n\nCompound Queries\n================\n\nIt is possible to use multiple combined queries, for example searching for models that have a specific title attribute,\nand either a category of \"abc\" or a tag of \"xyz\"\n\n```js\n_.query( MyCollection, {\n    $and: { title: {$like: \"News\"}},\n    $or: {likes: {$gt: 10}, color:{$contains:\"red\"}}\n});\n//Returns models that have \"News\" in their title and\n//either have more than 10 likes or contain the color red.\n```\n\n\nChainable API\n=============\n\nRather than supplying a single query object, you can build up the query bit by bit:\n\n```javascript\n _.query.build( MyCollection )\n  .and(\"published\", true)\n  .or(\"likes\", {$gt:10})\n  .or(\"tags\":[\"javascript\", \"coffeescript\"])\n  .run()\n```\n\nInstead of calling `_.query`, we call `_.query.build`. This returns a query object that we can build before running.\n`_.query.build` can take the collection that you want to query, or alternatively you can pass the collection in when\nrunning the query. Therefore these 2 both give the same results:\n\n```javascript\n results = _.query.build( MyCollection ).and(\"published\", true).run()\n results = _.query.build().and(\"published\", true).run( MyCollection )\n```\n\nTo build the query you can call `.and`, `.or`, `.nor` and `.not`.\nThese methods can accept either a query object, or a query key and a query value.  For example the following two examples\nare the same.\n\n```javascript\n results = _.query.build( MyCollection ).and({\"published\":true}).run()\n results = _.query.build( MyCollection ).and(\"published\", true).run()\n```\n\nTo run the query you can call either `.run`, `.all`, `.find`, or `.all`.\nThese methods are all aliases too each other and will run the query returning an array of results.\n\nTo retrieve just the first results you can use `.first`. For example:\n\n```javascript\n firstResult = _.query.build( MyCollection ).and({\"published\":true}).first()\n```\n\nIf you wish to perform further data manipulation using underscore, you can call the `.chain` method.\nThis will run the query and return the results as a wrapped underscore object, whcih you can then use methods like\n`.sortBy`, `.groupBy`, `.map`, etc.\n\n```javascript\ntitles = _.query.build( MyCollection )\n  .and(\"published\", true)\n  .or(\"likes\", {$gt:10})\n  .or(\"tags\":[\"javascript\", \"coffeescript\"])\n  .chain()\n  .sortBy(function(item) { return item.likes; })\n  .pluck(\"title\")\n  .value();\n```\n\nIndexing\n========\n\n\nMore documentation coming...\nEssentially you can add indexes when using the chainable syntax.\nYou can then perform queries as usual, but the results, should be faster on larger sets\nI suggest that you benchmark your code to test this out.\nThe index method takes either a single key, or a key and a function.\n\n\n```coffeescript\n\n    query = _.query(array)\n      .index(\"title\")\n\n    # could have been .index(\"title\", (obj) -> obj.title)\n\n    result = query.and(\"title\", \"Home\").run()\n```\n\n\n\n\n\nContributors\n===========\n\nDave Tonge - [davidgtonge](http://github.com/davidgtonge)\nRob W - [Rob W](https://github.com/Rob--W)\nCezary Wojtkowski - [cezary](https://github.com/cezary)\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/liquidg3/underscore-query/issues"
  },
  "homepage": "https://github.com/liquidg3/underscore-query",
  "_id": "underscore-query@0.4.0",
  "_shasum": "e18ed24565a0657a2f6d38964b352930e1212042",
  "_from": "../../../../tmp/npm-26669-6c3107e3/git-cache-282d9c9d6c99/d3f14a6e4c10590341639bc85ce1874eefc10921",
  "_resolved": "git+https://github.com/liquidg3/underscore-query.git#d3f14a6e4c10590341639bc85ce1874eefc10921"
}
